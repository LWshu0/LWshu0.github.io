---
title: 数据结构与算法前置知识
copyright: true
date: 2024-08-14 23:10:28
updated: 2024-08-14 23:10:28
tags:
    - 数据结构与算法
categories:
    - 数据结构与算法
excerpt: 介绍数据结构与算法中的前置知识
---

## 时间复杂度

### 基础概念

**时间复杂度**, 定义为一段程序中所有语句执行的频度之和, 记为 $T(n)$, 其中 $n$ 为问题的规模. 严格定义为: 若 $T(n)$ 和 $f(n)$ 为定义在正整数集合上的两个函数, 则存在正常数 $C$ 和 $n_0$ 使得当 $n>n_0$ 时, 都满足 $0 \leq T(n) \leq Cf(n)$, 则记 $T(n) = O(f(n))$.

**问题规模**, 定义为程序输入的大小.

### 简单情况

一般是给定一段程序分析时间内复杂度. 
对于嵌套循环需要考虑循环条件增加的情况, 是线性增加还是指数增加. 比如下面两个嵌套循环.

**循环一**
```c++
for(int i=0; i<n; i++){
    for(int j=0; j<n; j++){
        count++;
    }
}
```

**循环二**
```c++
for(int i=0; i<n; i++){
    for(int j=0; j<n; j*=2){
        count++;
    }
}
```

循环一的内层循环条件为线性增加的, 所以 `count++` 执行的次数就是 $n * n$ 次, 所以时间复杂度为 $O(n^2)$; 对于循环二, 内层循环条件为指数增加, 所以 `count++` 执行的次数为 $n * log_2n$ 次, 所以时间复杂度为 $O(nlog_2n)$. (注: 在上面两个例子中, C 都为 1)

对于稍微复杂的程序(问题规模为 $n$), 例如:

```c++
int i=0, sum=0;
while(sum<n){
    sum += ++i;
}
```

我们可以假定程序执行 $k$ 次, 那么就可以根据循环条件得到一个方程, 求解下列方程即可计算出时间复杂度:
$$
sum = \sum_{i=1}^{k}i = \frac{k(k + 1)}{2} = n \\
$$

这里不需要精确计算, 我们直接进行估计, 去掉不必要的常数, 可以得到新的方程, 即 $k^2 = n$, 所以程序得时间复杂度就是 $O(\sqrt{n})$

这个方法比较通用, 可以用于计算大部分不太容易直接看出得时间复杂度.

### 递推式

这里主要是指给出 $T(n)$ 的递推式, 让我们计算时间复杂度(也就是 $T(n)$).

简单的情况, 比如:
$$
T(n)=
\begin{cases}
1 & , n = 1 \\
T(n-1) + 1 & , n > 1
\end{cases}
$$

根据递推关系我们可以得出 $T(n) = T(n-1) + 1 = \dots = T(1) + n - 1 = n$, 所以时间复杂度就是 $O(n)$

对于稍复杂的情况, 我们需要应用 **主定理** 来帮助我们判断.

> 主定理: 对于任意一个递归函数, 我们可以写出其一般形式
> $$
> T(n) = \begin{cases}
>    O(1) & , n = n_0 \\
>    aT(\frac{n}{b}) + O(n^d) & , n > n_0
> \end{cases}
> $$
> 要求 $a \geq 1$, $b \gt 1$
> 1. 若 $d < log_ba$, 则 $T(n) = O(n^{log_ba})$
> 2. 若 $d = log_ba$, 则 $T(n) = O(n^d log_2n) = O(n^{log_ba}log_2n)$
> 3. 若 $d > log_ba$, 则 $T(n) = O(n^d)$

对于主定理变量的解释:
- **a**: 每次递归调用子问题的数量. 即在一个递归方法中, 需要调用几次子递归方法. 在二分查找中, 调用一次子递归, 则 $a = 1$.
- **b**: 子问题的规模缩小的比例. 例如二分法递归搜索时, 每次需要查找的数据都缩小了一半, 那么 b=2
- **d**: 每次递归中除了子递归调用之外的代码时间复杂度的参数. 例如二分法递归搜索时, 每次递归时除了调用子递归, 没有其他代码, 时间复杂度是 $O(1)$, 即 $n^d=1$, 因此 $d=0$
  
根据上面的解释, 我们可以得出二分查找符合主定理的情况 2, 带入 3 个参数可得时间复杂度为 $O(log_2n)$.

