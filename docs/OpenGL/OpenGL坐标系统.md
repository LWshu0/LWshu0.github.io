---
title: OpenGL坐标系统
copyright: true
date: 2023-09-02 14:00:59
updated: 2023-09-02 14:00:59
tags:
    - OpenGL
    - 课程笔记
categories:
    - 计算机图形学
    - OpenGL
excerpt: OpenGL中的坐标系统, 记录如何显示一个3D的物体
index_img: /img/OpenGL坐标系统/1693635010638.png
banner_img:
---
# 基本概述

坐标系统分为:

1. 局部坐标: 相对于物体本身原点的坐标
2. 世界空间坐标: 物体相对于世界全局的坐标, 用于物体在世界中的摆放
3. 观察空间坐标: 每个坐标都是相对于观察者的角度
4. 裁剪坐标: 裁剪坐标被处理到[-1.0, 1.0]之间, 是可显示在屏幕上的部分
5. 屏幕坐标: 通过**视口变换**的过程, 将[-1.0, 1.0]的变换到屏幕物理坐标(由 `glViewport`函数所定义的坐标范围), 变换后的坐标将被送往光栅器转换为片段

![1693635010638](/img/OpenGL坐标系统/1693635010638.png)

# 空间描述

## 局部空间

只考虑一个物体, 其中的坐标都相对于物体的原点, 比如之前的那个箱子, 原点是(0, 0), 他的坐标被限制在(-0.5, 0.5)的范围中.

## 世界空间

由**模型矩阵**实现从局部坐标到世界坐标的变换, 其描述了一个物体在世界中的位置(包括朝向), 通过组合适当的位移, 旋转矩阵得到.

## 观察空间

也称为**摄像机**空间或者视觉空间, 是用户可以通过摄像机看到的空间. 观察矩阵用来将世界坐标转换为观察空间坐标, 通常是平移与旋转的组合矩阵.

## 裁剪空间

在顶点着色器最终的输出结果中, 所有的坐标都被限制在一个特定的范围中, 超出的顶点都被裁剪掉, 剩下的就是屏幕上可见的片段. 如果一个三角形的一部分超出了屏幕, 且在屏幕中的部分不是三角形, OpenGL会把屏幕中的部分分割成多个三角形然后再去处理. **投影矩阵**完成从观察坐标到裁剪空间坐标的转换, 投影矩阵指定了一个坐标范围, 超出坐标范围的点将不会显示.

### 正射投影

正射投影的观察箱如下图所示, 仅在 `NEAR PLANE`和 `FAR PLANE`两个平面之间的点是可见的.

![正射投影观察箱](https://learnopengl-cn.github.io/img/01/08/orthographic_frustum.png)

定义这么一个立方体空间的方法:

```c++
glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);
```

参数含义:

1. 平面的左侧坐标
2. 平面的右侧坐标
3. 平面的底部坐标
4. 平面的顶部坐标
5. 近平面的距离
6. 远平面的距离

### 透视投影

**近大远小**的显示物体, 这是符合我们实际的显示方式. 透视投影的观察箱是一个近面与远面不相同大小的平截头体, 同样超出这个范围的点不会显示.

![透视投影观察箱](https://learnopengl-cn.github.io/img/01/08/perspective_frustum.png)

```c++
glm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f);
```

参数含义:

1. 视角大小弧度, 设置为45°是比较真实的观察效果
2. 视口的宽高比
3. 近平面的距离
4. 远平面的距离

> 如果近平面的距离设置的太大, 当太靠近物体时视线会穿透物体

**透视除法**

应用透视投影会改变顶点的w分量, 越远的物体w分量越大, 然后应用透视除法(如下公式)改变顶点坐标达到近大远小的效果. 而使用正射投影的时候, w分量总为1.

$$
out = \begin{pmatrix} x /w \\ y / w \\ z / w \end{pmatrix}
$$

# 3D

局部空间的顶点坐标$V_{local}$经过模型矩阵$M_{model}$, 观察矩阵$M_{view}$, 投影矩阵$M_{projection}$的变换最终得到顶点着色器的输出裁剪坐标$V_{clip}$, 这一系列变换都是在顶点着色器中完成的任务.

$$
V_{clip} = M_{projection} \cdot M_{view} \cdot M_{model} \cdot V_{local}
$$

## 3D箱子

不使用EBO绘图, 否则会导致纹理坐标和顶点坐标对不上, 渲染出的图形不是所期望的那样. 用 `glDrawArrays(GL_TRIANGLES, 0, 36);`直接绘制VBO.

**Z缓冲/深度缓冲**, 使物体的显示具有遮挡效果, 使用 `glEnable(GL_DEPTH_TEST);`来开启OpenGL中Z缓冲的选项. 启用Z缓冲后, 每次渲染之前都要清除之前的Z缓冲, 在 `glClear`中添加 `GL_DEPTH_BUFFER_BIT`即可.
