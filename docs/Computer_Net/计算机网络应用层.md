---
title: 计算机网络应用层
copyright: true
date: 2023-09-06 22:08:55
updated: 2023-09-13 00:08:55
tags: 
    - 计算机网络
    - 课程笔记
categories:
    - 计算机网络
    - 课程学习笔记
#excerpt:
#index_img:
#banner_img:
---
# 应用层协议原理

## 网络应用程序体系结构

### 客户-服务器体系结构

该体系结构中存在一个总是打开的主机---**服务器**, 服务器服务来自其他主机(**客户**)的请求.

**服务器(server)**

1. 总处于开机状态
2. 有固定的IP
3. 可以扩展以具有多个server

**客户(client)**

1. 可以和服务器交互
2. 可能中断(即关机)
3. 可以有动态IP
4. 客户之间不能直接通讯

### 对等体系结构(P2P)

应用程序在间断连接的主机对之间使用直接通信, 这些主机对被称为**对等方**

1. 主机不总是在线的
2. 对等方可以直接交互, 不需要通过服务器
3. 可以从多个对等方获取数据
4. 自扩展性
5. 主机的IP可变

## 进程通信

在两个不同端系统上的进程, 通过跨越计算机网络交换**报文(message)**而相互通信. 发送进程生成并向网络中发送报文; 接收进程接收这些报文并**可能**通过回送报文进行响应.

### 客户和服务器进程

在一对进程之间的通信会话场景中, 发起通信(即在该会话开始时发起与其他进程的联系)的进程被标识为客户, 在会话开始时等待联系的进程是服务器. 有时也使用应用程序的客户端和服务器端, 一个进程可以既是客户又是服务器.

### 进程与计算机网络之问的接口

进程通过一个称为套接字 (socket) 的软件接口向网络发送报文和从网络接收报文. 套接字是同一台主机内应用层与运输层之间的接口. 由于该套接字是建立网络应用程序的可编程接口, 因此套接字也称为应用程序和网络之间的应用程序编程接口(API). 应用程序开发者只能控制套接字在应用层一端的一切, 在运输层一端的几乎无法控制.

### 进程寻址

必须知道如下两个地址:

1. 主机的地址(IP地址)
2. 在目的主机中指定接收进程的标识符(端口号)

## 可供应用程序使用的运输服务

- 可靠数据传输: 确保由应用程序的一端发送的数据正确, 完全地交付给该应用程序的另一端
- 吞吐量: **可用吞吐量** 就是发送进程能够向接收进程交付比特的速率, 运输层协议能够以某种特定的速率提供确保的可用吞吐量(提供的大于等于需要的)
- 定时: 限定数据从发送方到接收方的时间
- 安全性: 对发送的数据进行加密, 防止除发送方和接收方进程之外的其他应用知道数据的具体内容

## 因特网提供的运输服务

因特网(更一般的是 TCP/IP 网络)为应用程序提供两个运输层协议，即 UDP 和 TCP.

### TCP

提供面向连接服务和可靠数据传输服务

- 可靠的数据传送服务: 通信进程能够依靠TCP, 无差错、按适当顺序交付所有发送的数据
- 流量控制: 发送端和接收端的协调, 流量取发送端发送速率与接收端接受速率的最小值
- 拥塞控制: 由于发送端和接收端之间的网络拥塞而抑制发送速率, 减少丢包率
- 基于连接服务: 通信前必须先确认对方存在; 通信过程中接收方接收到数据要向发送方发送一个响应(是否正常受到, 数据是否有错误等)

### UDP

UDP 是一种不提供不必要服务的轻量级运输协议, 它仅提供最小服务. 没有握手过程, 不提供可靠的数据传送服务. 没有拥塞控制机制, 将以选定的速率发送数据.

### SSL

添加到应用层与TCP之间的新层, 用于加密数据, 使得TCP更加安全. 这体现了层次结构的可扩展性, 即可以在两层之间添加新层, 只要提供的接口正确.

### 不提供的服务

因特网传输协议不提供吞吐量和定时的保证

## 应用层协议

**应用层协议(application-layer protocol)** 定义了运行在不同端系统上的应用程序进程如何相互传递报文

- 交换报文的类型
- 各种报文类型的语法
- 字段的语义
- 进程何时如何发送报文, 响应报文

# Web和HTTP

## HTTP

超文本传输协议 ( HyperText Transfer Protocol, HTTP), 由一个客户端和一个服务器程序实现. 用户向服务器发送请求报文, 服务器返回页面中的对象. HTTP使用TCP作为运输协议, 这保证数据的完整性.

HTTP 服务器并不保存关于客户的任何信息, 所以我们说 HTTP 是一个无状态协议 (stateless protocol ), 与之相对的是有状态协议, 服务器可以记住用户信息(比如记住密码后自动登录, 网购时的购物车等)

- 非持续连接的 HTTP: 完成传输一个请求后即关闭链接. 每一个对象都有一个TCP链接, 意味着可以并行传输一个网页上的多个对象.
- 持续连接的 HTTP: 服务器在发送响应后保持该 TCP 连接打开, 经过一段时间不使用后就关闭

## HTTP报文

### 请求报文

```
GET /index.html HTTP/1.1\r\n
Host: www-net.cs.umass.edu\r\n
User-Agent: Firefox/3.6.10\r\n
Accept: text/html,application/xhtml+xml\r\n
Accept-Language: en-us,en;q=0.5\r\n
Accept-Encoding: gzip,deflate\r\n
Accept-Charset: ISO-8859-1,utf-8;q=0.7\r\n
Keep-Alive: 115\r\n
Connection: keep-alive\r\n
\r\n
```

![1694441530682](/img/计算机网络应用层/1694441530682.png)

- method有GET, POST, HEAD, PUT(上传文件到指定的URL), DELETE(删除对应URL的文件)
- URL 是所请求资源的对象标识
- version 指定http的版本, 上面的例子中使用的是http 1.1

### 响应报文

```
HTTP/1.1 200 OK\r\n 
Date: Sun, 26 Sep 2010 20:09:20 GMT\r\n
Server: Apache/2.0.52 (CentOS)\r\n
Last-Modified: Tue, 30 Oct 2007 17:00:02
GMT\r\n
ETag: "17dc6-a5c-bf716880"\r\n
Accept-Ranges: bytes\r\n
Content-Length: 2652\r\n
Keep-Alive: timeout=10, max=100\r\n
Connection: Keep-Alive\r\n
Content-Type: text/html; charset=ISO-8859-
1\r\n
\r\n
data data data data data ...
```

第一行是状态行, 包括协议(HTTP/1.1) 状态码(200), 状态短语(OK)

状态码:

- 200 OK
- 301 Moved Permanently
- 400 Bad Request
- 404 Not Found
- 505 HTTP Version Not Supported

### 一些重要的概念

#### 长连接

HTTP报文中的 `Connection: keep-alive` 指明当前连接是一个长连接, 服务器需要一直保持这个连接不断开. 在 HTTP 1.1 中, 长连接是默认开启的, 而 HTTP 1.0 是默认关闭的, 想要关闭该长连接只需要客户端在请求报文或者服务器在返回报文中加入 `Connection: close` 即可, 此时该条报文将是这个连接上最后一条报文.

长连接还可以指定过期时间, 在报文中加入 `Keep-Alive: timeout=10` 说明该tcp连接最多保持10秒, 另外还有 `max=100` 说明这个长连接最多接收100次请求就断开连接.

#### 并发连接数

[RFC文档](https://www.cnblogs.com/Kimbing-Ng/p/12411017.html)说，客户端与服务器最多就连上**两**通道，但服务器、个人客户端要不要这么做就随人意了，有些服务器就限制同时只能有1个TCP连接，导致客户端的多线程下载（客户端跟服务器连上多条TCP通道同时拉取数据）发挥不了威力，有些服务器则没有限制.

## cookie

![1694441910211](/img/计算机网络应用层/1694441910211.png)

cookies主要用于保存用户数据, 比如记住密码自动登录, 购物车, 推荐系统等等.

## web缓存

![1695457215438](/img/计算机网络应用层/1695457215438.png)

Web缓存服务器也叫做代理服务器, 他会存储最近请求过的对象的副本, 当用户在此请求这个对象时, 只需要到web缓存中请求即可(速度更快).

如果请求的对象Web缓存中没有, 那么Web缓存就会建立一个到初始服务器的TCP连接去请求这个对象并保存在缓存中, 同时发送给客户端. 在这个过程中Web缓存既是服务器(相对于client)也是客户端(相对于origin server)

![1695457745603](/img/计算机网络应用层/1695457745603.png)

考虑上图中的网络拓扑, 在LAN中配置有一个机构缓存器, 命中率假设为0.4(几乎没有时延). 同时假设机构内的浏览器访问初始服务器的平均速率为每秒15个请求, 而且每个请求报文大小忽略不计, 每个请求的对象大小为1M bits

当没有机构缓存时, 所有的请求都要经过 access link, 请求数据的速率为 $1Mb \times 15ps = 15Mbps$, 流量强度趋近于1, 这样的排队时间会很长.

加入机构缓存后, 只有0.6的请求需要经过 access link, 请求数据的速率为 $1Mb \times 0.6 \times 15ps = 9.6Mbps$, 流量强度为0.64, 排队时间较短.

## 条件GET

解决缓存服务器与初始服务器之间内容不一致的问题, 请求报文使用 `GET`方法, 并且报文头包含一个 `If-Modified-Since:` 的首部行, 该条请求报文就是**条件GET**请求报文.

例如, 缓存服务器向初始服务器发送了一个请求, 初始服务器返回了如下响应报文, 其中包含了最后修改日期:

```
HTTP/1.1 200 OK
Date : Sat,3 Oct 2015 15:39:29
Server : Apache/1.3.0 (Unix}
Last-Modified: Wed, 9 Sep 2015 09:23:24
Content-Type : image/gif
(data data data data data ... )
```

假设一周后, 一个用户经过缓存服务器再次请求该对象, 但是缓存上的该对象可能不是最新的了(初始服务器上的该对象被更改), 缓存服务器就要发送一个条件GET去检查更新:

```
GET /fruit/kiwi.git HTTP/1.l
Host: www.exotiquecuisine.com
If-modified-since : Wed, 9 Sep 2015 09:23:24
```

初始服务器返回响应, 因为没有修改所以为了节省资源, 没有返回任何数据:

```
HTTP/1.1 304 Not Modified
Date: Sat,10 Oct 2015 15:39:29
Server: Apache/1.3.0 (Unix)
(empty entity body)
```

# 因特网中的电子邮件

由三个主要组成部分: **用户代理**, **邮件服务器**, **简单邮件传输协议(SMTP)**

## SMTP

> SMTP是一个推协议, 只负责发送邮件, 包括从发送方的客户端到它的邮件服务器, 从源邮件服务器到目的邮件服务器.

![1695460831590](/img/计算机网络应用层/1695460831590.png)

邮件客户端(也叫mail reader), 负责编写, 更改, 读取邮件消息, 发送和接收的消息都在服务器上.

邮件服务器

- mailbox 包含用户收到的邮件
- message queue 包含将要发送的邮件, 如果接收服务器没有开机, 邮件将会暂存在这里并等待发送
- SMTP 协议 负责在服务器之间发送邮件(不使用中间服务器, 直接建立源到目的的一条TCP连接)

**SMTP连接过程**

![1695461409908](/img/计算机网络应用层/1695461409908.png)

当完成TCP三次握手(即成功建立了TCP连接), 接下来就是SMTP连接的三次握手, 完成后即可开始进行SMTP的传输. 下面是一段在建立TCP连接后可能的对话:

```
S : 220 hamburger. edu
C : HELO crepes . fr
S : 250 Hello crepes . fr , pleased to meet you
C : MAIL FROM: <alice@crepes.fr>
S : 250 alice@crepes.fr ... Sender ok
C : RCPT TO: <bob@hamburger.edu>
S : 250 bob@hamburger.edu ... Recipient ok
C : DATA
S : 354 Enter mail, end with"." on a line by itself
C : Do you like ketchup?
C : How about pickles?
C : .
S : 250 Message accepted for delivery
C : QUIT
S : 221 hamburger.edu closing connection
```

**报文格式**

```
From: alice@crepes.fr
To: bob@hamburger.edu
Subject: Searching for the meaning of life.
<空白行>
<以 ASCII 码格式表示的报文体>
```

## 邮件访问协议

目前流行的有第三版的邮局协议 (Post Office Protocol—Version 3, POP3)、因特网邮件访问协议 (Internet Mail Access Protocol IMAP) 以及 HTTP. 这些协议负责将邮件从邮件服务器拉取到客户端.

POP3命令, 下面是一种可能的对话.

```
S: +OK POP3 server ready
C: user bob
S: +OK
C: pass hungry
S: +OK user successfully logged on
C: list
S: 1 498
S: 2 912
S: .
C: dele 1
C: retr 2
S: <message 1 contents>
S: .
C: dele 2
C: quit
S: +OK POP3 server signing off
```

用户命令

- user 指明用户名
- pass 输入密码
  服务器回答
- +OK
- -ERR
  数据交换阶段
- list 列出邮件编号, 大小
- retr 通过邮件编号检索邮件
- dele 从服务器中删除指定邮件(当用户配置了读取并删除模式时会有此句)
- quit 退出

# DNS: 因特网的目录服务

标识一个主机可以通过**主机名(hostname)**, 如 www.google.com, www.facebook.com等, 但其中包含的有关主机在因特网中的位置信息却很少. 因此主机也可以通过**IP地址**进行标识.

## DNS(domain name system, 域名系统)提供的服务

- 通过客户-服务器模式为用户提供主机名解析到IP地址的服务. DNS通常由其他应用层协议所使用, 包括HTTP, SMTP, FTP. 我们想获得的IP地址通常缓存在一个"附近的"DNS服务器中, 有助于减少网络流量和DNS平均时延.
- 主机别名. 一台主机有一个**规范主机名**, 另外还可以有一个或多个别名, 主机别名通常比主机规范名更加容易记忆. 用户可以调用DNS来获得对应主机别名的IP地址(与用主机规范名得到的是一致的).
- 邮件服务器别名. 与主机别名一致, 通过为服务器起别名来帮助记忆.
- 在冗余服务器之间进行负载分配. 繁忙的站点被冗余分配到不同的端系统上, 有着不同的IP, 这造成了一个主机名对应多个不同的IP. DNS在这些IP之间进行循环分配负载(或用更复杂的方式)使得访问每个服务器的请求均衡.

## DNS结构

![1695474260381](/img/计算机网络应用层/1695474260381.png)

- 根DNS服务器. 全世界有13台IPV4根DNS服务器, 一个主根服务器在美国. 其中提供TLD服务器的IP地址.
- TLD(Top-Level Domain)服务器. 对于每个顶级域(如 com、org、net、edu和gov)和所有国家的顶级域(如uk、fr、ca和jp)都有TLD服务器. 其中提供了权威DNS服务器的IP地址.
- 权威DNS服务器. 存储一个组织的主机名到IP地址的映射
- 本地DNS服务器. 并不包含在上图中, 每一个ISP(公司, 大学等)有一台. 当用户发起DNS查询时, 用户会访问本地DNS服务器, 再由本地服务器去根DNS服务器等查询, 起到一个代理的作用.

## DNS查询

**迭代查询**

![1695475011470](/img/计算机网络应用层/1695475011470.png)

**递归查询**

![1695475046809](/img/计算机网络应用层/1695475046809.png)

## DNS缓存

当一个DNS服务器接收到一个DNS回答时, 它会把接收到的映射存储在本地存储器中. 因为主机名到IP的映射不是永久的, 所以DNS服务器在一段时间(通常是2天)后会丢弃缓存的消息. 本地DNS服务器可以缓存TLD服务器的IP, 因此大部分查询都不会经过根DNS服务器.

## DNS记录

**资源记录(Resource Record, RR)** 提供了主机名到IP地址的映射, 每一个DNS回答报文可以包含一个或多个资源记录.

RR主要包含一个四元组: (name, value, type, TTL), 根据type的不同, 各字段有不同的含义

| type  | name           | value                                             |
| ----- | -------------- | ------------------------------------------------- |
| A     | 主机名         | IP地址                                            |
| CNAME | 主机别名       | 规范主机名                                        |
| NS    | 域名           | 知道如何获得该域名的IP地址的权威DNS服务器的主机名 |
| MX    | 邮件服务器别名 | 邮件服务器规范主机名                              |

## DNS报文

![1695476104658](/img/计算机网络应用层/1695476104658.png)

- 前12个字节为**首部区域**. 标识符用于标识该查询, 与响应报文相同从而匹配请求与回复. 标志字段有许多标志位, 代表该报文是查询报文/回答报文, 递归查询/迭代查询等. 接下来四个数量对应后续字段中的数量
- **问题**是正在查询的信息, 包括正在被查询的主机名字, 问题类型(A/NS等)
- **回答**包括多条RR(因为一个主机可以有多个IP), 是对上述问题的回答
- **权威**包含了权威服务器的记录
- **附加**包括了其他有帮助的记录

# P2P体系结构

## 分发时间

一个大小为$F$ bits的文件要分发给$N$个用户, $u_i$为第i个用户的上传速率, $d_i$为第i个用户的下载速率, 并定义 $d_{min} = min\{d_1, d_2, \dots, d_N\}$, $u_s$是服务器上传速率.

**C-S体系结构**
服务器需要上传$N$份文件的拷贝, 也就是$NF$ bits, 上传的时间为 $\frac{NF}{u_s}$, 而每个用户需要的接收时间为 $\frac{F}{d_{min}}$. 所以可以得到分发时间的下界为

$$
max \left\{\frac{NF}{u_s}, \frac{F}{d_{min}} \right\}
$$

**P2P体系结构**
此时服务器只需要上传一份文件即可, 所以用时为 $\frac{F}{u_s}$ . 与C-S体系结构类似, 下载时间最小为 $\frac{F}{d_{min}}$. 考虑整个结构的上传能力, 一共有$N$份文件需要上传到网络, 整体上传速率(包括服务器)为 $u_s+ \sum\limits_{i=1}^{N}u_i$, 所以用时最少为 $\frac{NF}{u_s+ \sum\limits_{i=1}^{N}u_i}$. 可以得到分发时间下界为

$$
max \left\{\frac{F}{u_s}, \frac{F}{d_{min}}, \frac{NF}{u_s+ \sum\limits_{i=1}^{N}u_i} \right\}
$$

![1695482800976](/img/计算机网络应用层/1695482800976.png)

## BitTorrent

BitTorrent是一种用于文件分发的P2P协议, 简称BT. 参与一个特定文件分发的所有对等方称为一个洪流(torrent), 洪流中的对等方彼此下载等长度的文件块(chunk), 典型的块长度是256KB.

洪流中有一个基础设施节点, 成为**追踪器(tracker)**, 当一个对等方加入洪流时, 需要向追踪器注册自己, 并周期性的告知追踪器自己仍在洪流中.

用户在加入洪流时可能没有任何文件块, 但是随着时间会逐渐积累, 一旦某个用户获得了整个文件, 它可以选择退出洪流或者留在洪流中为其他相邻(建立TCP连接)的对等方上传数据. 对等方的相邻关系不是一成不变的.

其中一个用户会针对它没有的块, 优先向它的邻居请求邻居最稀缺的块(即副本最少), 这将使每个块在洪流中的副本数量趋于均衡.

一报还一报(tit-for-tat), 用户选择当前能以最高速率向它提供数据的邻居, 给出其优先权(向它们传输数据的速率会是最高的), 这样子对等方会趋向于找到彼此协调的速率上载.

# 视频流和内容分发网

## HTTP流和DASH

HTTP流的视频在服务器上存储为一个普通的文件, 通过HTTP GET请求视频文件, 并在客户端中缓存, 当缓存中的数据超过设定的门限后就开始播放.

**经HTTP的动态适应性流(Dynamic Adaptive Streaming over HTTP, DASH)** 为了解决不同用户带宽不同, 所能接受的视频质量也不同的问题所提出. 它将视频分为不同的比特率, 对应不同的质量水平, 客户动态的选择请求哪一种视频段数据块.

## 内容分发网(CDN)

CDN是分布于世界各地的数据中心, 存储数据副本. CDN 管理分布在多个地理位置上的服务器, 在它的服务器中存储视频(和其他类型的 Web 内容，包括文档 、图片和音频)的副本, 并且所有试图将每个用户请求定向到一个将提供最好的用户体验的 CDN 位置.

集群选择策略, 即动态的将客户定向到CDN中某个服务器集群或数据中心的机制. 一种简单的策略是选择地理上最为邻近的集群, 另外也可以通过实时测量客户到集群的时延和丢包率来选择最好的集群.

# 套接字编程

详情可见网络编程一节
