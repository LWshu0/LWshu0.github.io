---
title: 网络套接字聊天程序
copyright: true
date: 2023-09-28 23:59:58
updated: 2023-09-28 23:59:58
tags:
    - 项目
    - 计算机网络
    - C++
categories:
    - 项目
    - 网络聊天程序
excerpt: 关于我写的一个网络聊天程序的说明与收获, 总结在本次小项目中学到的知识.
---
# 知识总结

## 动态类成员函数作为 pthread_create 的回调函数

自从大一学完 c++ 已经很久不去注意这些小细节了, 虽然当时学过 `this` 指针, 也知道这是个什么东西, 但现在确实有些忘记了. 本项目中应用了多线程, 为了保持服务器类的封装性, 打算将多线程相关的内容也一同放进类方法中, 不过发现 `pthread_create` 函数的回调函数参数不能是类成员方法(准确来说不能是**动态**类成员方法).

为了能让线程执行类成员方法, 可以有三个方法, 下面分别阐述.

1. 声明一个普通函数作为回调函数, 在其中调用类成员方法. 一开始我的做法就是这样子的, 但是很明显无法做到很好的封装性.
2. 将成员函数声明为静态成员函数(即用 `static` 修饰). 缺点是使用此方法声明的函数不能访问动态成员变量.
3. 将成员函数强制转换为回调函数类型. 这是能很好的完成封装的方法, 但是缺点是需要占用回调函数的参数位置用来存放 `this`指针.

接下来将详细的对方法3进行说明, 考虑下面的程序, 声明一个 `A`类, 其中有一个动态成员变量 `data`存放数据. 一个线程句柄数组, 用来创建多线程. `dm`互斥锁是保证 `cout`的正确性(因为cout是线程不安全的). 成员函数 `fun`是多线程的回调函数, `run`是启动多线程的方法(完成了很好的封装).

该程序可以证明 `fun`的第一个参数是隐藏的 `this`指针, 注意这里 `fun`的声明是没有显式的参数的, 但是线程执行时还是向它传了一个参数也就是隐藏的 `this`指针.

那么为什么要向它传 `this`指针呢? 编译器不是会给成员函数自动添加一个隐藏的 `this`指针吗? **这里传递函数指针时做了强制转换, 已经不是成员函数了, 编译器就不会自动为它添加 `this`指针**, 我们传递的 `this`指针就是完成了编译器不做的工作.

```c++
typedef void*(*t_fun)(void*);

class A;

A* b_p = nullptr;

class A{
private:
	int data;
	pthread_t th[5];
	pthread_mutex_t dm = PTHREAD_MUTEX_INITIALIZER;
public:
	A(int d = 0){
		data = d;
	}
	void* fun(){
		pthread_mutex_lock(&dm);
		cout << data << endl;
		data += 2;
		pthread_mutex_unlock(&dm);
		return (void*)0;
	}
	void run(){
		for(int i=0;i<5;i++){
			pthread_create(&th[i], 0, (t_fun)&fun, b_p);
		}
	
		for(int i=0;i<5;i++){
			pthread_join(th[i], 0);
		}
	}
};

int main(){
	A a(1); // a 将输出奇数
	b_p = &a; // 取得实例 a 的 this 指针
	A b(2); // b 将输出偶数
	a.run();
	b.run();
}
```

运行结果如下图所示, 按理来说 `a`应该输出奇数, `b`应该输出偶数, 但结果都是奇数, 为什么? 因为我们给回调函数传递的是 `a`的 `this`指针(就是程序中的 `b_p`), 所以即使运行的是 `b`的 `run`函数, `b`的 `fun`函数, `fun`函数内访问的却是 `a`的 `data`.

![1695918538600](/img/网络套接字聊天程序/1695918538600.png)
