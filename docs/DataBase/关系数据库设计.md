---
title: 关系数据库设计
copyright: true
date: 2023-10-19 22:38:02
updated: 2023-10-24 22:38:02
tags:
    - 数据库
    - 课程笔记
categories:
    - 数据库
    - 课程学习笔记
#excerpt:
#index_img:
#banner_img:
---
# 关系数据库设计

## 基础概念

**域** 是属性的取值范围, 如果一个域的元素不可再分, 则一个域是 **原子的**. 这里的原子性还是会由我们的理解方式来确定, 比如一个整数, 如果我们把它看成一个整数那它就是原子的, 但如果我们把它看成是一列有序数字, 则它就不是原子的.

属性集使用希腊字母表示, 如 $\alpha$. 使用罗马字母加大写字母表示关系模式, 如 $r(R)$, $r(A_1, A_2)$, 其中 r 表示关系, R 表示属性集. 关系模式的超码使用 $K$ 表示.

对于一个关系模式 $r(R)$ , 有属性集 $\alpha, \beta \subseteq R$ , 如果对关系模式中的任意元组 $t_1, t_2$ 满足 $t_1[\alpha] = t_2[\alpha]$, 则 $t_1[\beta] = t_2[\beta]$, 那么就称这个关系模式满足 **函数依赖** $\alpha \to \beta$, 或者说该函数依赖在关系模式 $r(R)$ 上成立.

对于函数依赖 $\alpha \to \alpha$, 可知其自然满足 $t_1[\alpha] = t_2[\alpha]$, 则 $t_1[\alpha] = t_2[\alpha]$, 称这种函数依赖为 **平凡的**. 进一步推广, 如果函数依赖 $\alpha \to \beta$ 中, $\beta \subseteq \alpha$ 则该函数依赖是平凡的.

对于属性集 $A, B, C$, 已知函数依赖 $A \to B$ 和 $B \to C$, 可以 **推导** 出 $A \to C$.

## 函数依赖理论

### 函数依赖的闭包

#### 定义

对于函数依赖集 $F$, 由 $F$ 可以推导出的所有函数依赖构成的集合 $F^+$ 称为 $F$ 的 **闭包**.

#### 构造方式

**Armstrong公理**

- **自反律**. 若 $\alpha, \beta$ 为属性集, 且 $\beta \subseteq \alpha$, 则 $\alpha \to \beta$ 成立.
- **增补律**. 若 $\alpha \to \beta$ 成立且 $\gamma$ 为一属性集, 则 $\gamma\alpha \to \gamma\beta$ 成立.
- **传递律**. 若 $\alpha \to \beta$ 和 若 $\beta \to \gamma$ 成立, 则 $\alpha \to \gamma$ 成立.

**由Armstrong推导出的定理**

- **合并律**. 若 $\alpha \to \beta$ 和 $\alpha \to \gamma$ 成立, 则 $\alpha \to \beta\gamma$ 成立.
- **分解律**. 若 $\alpha \to \beta\gamma$ 成立, 则 $\alpha \to \beta$ 和 $\alpha \to \gamma$ 成立.
- **伪传递律**. 若 $\alpha \to \beta$ 和 $\gamma\beta \to \delta$ 成立, 则 $\alpha\gamma \to \delta$ 成立.

### 属性集的闭包

#### 定义

如果 $\alpha \to B$, 称属性 B 被属性集 $\alpha$ **函数确定**. 在函数依赖集 $F$ 下所有被 $\alpha$ 函数确定的属性集合构成 $\alpha$ 的 **属性集闭包**, 记为 $\alpha^+$.

#### 构造方式

在函数依赖集 $F$ 下, $\alpha$ 的属性集闭包构造方式:

$result :=  \alpha$;
    **repeat**
        **for eaach** 函数依赖 $\beta \to \gamma$ **in** $F$ **do**
            **begin**
                **if** $\beta \subseteq result$ **then** $result := result \cup \gamma$
            **end**
    **until** ($retult$ 不变)

#### 属性集闭包用途

- 若 $\alpha$ 的属性集闭包 $\alpha^+$ 包括关系 $R$ 的所有属性, 则 $alpha$ 为超码.
- 若 $\beta \subseteq \alpha^+$ 则 $\alpha \to \beta$ 成立.
- 计算 $F^+$. 如果对任意 $\gamma \subseteq R$, 有任意 $S \subseteq \gamma^+$, 可以得到函数依赖 $\gamma \to S$.

### 无关属性

#### 定义

在一个函数依赖中去除 **无关属性** 不改变函数依赖集的闭包. 对于函数依赖 $\alpha \to \beta$ . 形式化定义如下:

- 若 $A \in \alpha$ 且 $F$ 逻辑蕴含 $(F - \{\alpha \to \beta\}) \cup \{(\alpha - A) \to \beta\}$, 则属性 $A$ 在 $\alpha$ 中是无关的
- 若 $A \in \beta$ 且 $(F - \{\alpha \to \beta\}) \cup \{\alpha \to (\beta - A)\}$ 逻辑蕴含 $F$, 则属性 $A$ 在 $\beta$ 中是无关的

### 正则覆盖

#### 定义

$F$ 的正则覆盖 $F_c$ 是一个函数依赖集, 需要满足:

- $F$ 逻辑蕴含 $F_c$ 中所有依赖, 且 $F_c$ 逻辑蕴含 $F$ 中所有依赖
- $F_c$ 中任何函数依赖都不含无关属性
- $F_c$ 中函数依赖的左半部都是唯一的, 即不存在两个依赖 $\alpha_1 \to \beta_1$ 和 $\alpha_2 \to \beta_2$ 使得 $\alpha_1 = \alpha_2$

$F_c$ 和 $F$ 具有相同的依赖集闭包, 且 $F_c$ 不包含无关属性, 是最小的.

#### 构造

$F_c = F$
    **repeat**
        使用合并律将 $F_c$ 中所有形如 $\alpha_1 \to \beta_1$ 和 $\alpha_1 \to \beta_2$ 的依赖替换为 $\alpha_1 \to \beta_1\beta_2$
        在 $F_c$ 中寻找函数依赖 $\alpha \to \beta$, 它在 $\alpha$ 或在 $\beta$ 中具有一个无关属性
        如果找到一个无关属性, 就将它从 $F_c$ 中的 $\alpha \to \beta$ 中删除
    **until** $F_c$ 不变

### 无损分解/有损分解

无损分解和有损分解有时称为无损连接分解和有损连接分解, 关系模式 $r(R)$ 中将属性集 $R$ 分解为 $R_1, R_2$, 如果用 $r_1(R_1), r_2(R_2)$ 代替 $r(R)$ 时没有信息损失, 则称该分解是无损分解. 否则就是有损分解.

如果 $R_1 \cap R_2$ 是 $R_1$ 或者 $R_2$ 的超码, $R$ 上的分解就是无损分解.

### 保持依赖

令 $F$ 为模式 $R$ 上的一个函数依赖集, $R_1, R_2, \dots, R_n$ 为 $R$ 的一个分解, $F$ 在 $R_i$ 上的 **限定** 是 $F^+$ 中所有只包含 $R_i$ 中属性的函数依赖集合 $F_i$. 令 $F' =F_1 \cup F_2 \cup \dots \cup F_n$, 如果 $F'^+ = F^+$ 则该分解是保持依赖的分解.

**验证方法**

详见教材P195

对于函数依赖集 F, 考虑其中的每一个函数依赖 $\alpha \to \beta$ 如果这些函数依赖能够在某一个 $F_i$ 上成立, 那么该分解就是保持依赖的. 验证成立可以通过计算 $\alpha$ 的属性集与 $R_i$ 的交集的闭包和 $R_i$ 的交集, 如果 $\beta$ 属于第二个交集, 那么函数依赖就在 $F_i$ 中成立.

例: R = {A, B, C, D, E} , F = {B $\to$ A, D $\to$ A, A $\to$ E, AC $\to$ B}, 分解为 $R_1$ = {ABCE}, $R_2$ = {CD}, 判断分解是否保持依赖.

解答: 考虑 B $\to$ A, B与 $R_1$ 的交集为 B, 计算 B 在 F 下的闭包为 {BEA}, 与 $R_1$ 的交集为 {BEA}, 此时 A 属于交集, 所以函数依赖 B $\to$ A 是保持的. 考虑 D $\to$ A, D与 $R_1$ 的交集为空不考虑, D 与 $R_2$ 的交集为D, 计算D在F下的闭包为 {DAE}, 与 $R_2$ 的交集为 {D}, 而A不属于交集, 所以该依赖不保持. 此时就可以停止计算并判断分解不保持函数依赖.

## 关系模式的范式

### 第一范式

#### 定义

关系 R 的所有属性的域都是原子的.

### Boyce-Codd 范式

#### 定义

关系模式 $R$ 的函数依赖集 $F$ 的闭包 $F^+$ , 对于 $F^+$中任意的函数依赖 $\alpha \to \beta$ 有以下至少一项成立:

- $\alpha \to \beta$ 是平凡的函数依赖
- $\alpha$ 是模式 $R$ 的一个超码

#### 判断方法

- 检查非平凡函数依赖 $\alpha \to \beta$ 需要计算 $\alpha^+$ 是否包含 R 中所有属性即验证 $\alpha$ 是否为超码.
- 检查关系模式 R 需要检查其函数依赖集 F 中所有的函数依赖是否违反 BCNF.
- 判断分解后的关系 $R_i$ 是否符合 BCNF, 需要检查对于 $R_i$ 的每一个子集 $\alpha$ 确保 $\alpha^+$ 要么不包含 $R_i-\alpha$ 的任何属性, 要么包含 $R_i$ 的所有属性.

#### BCNF分解

将一个不属于 BCNF 的模式 $R$ 用下面的两个模式替换, 其中 $\alpha$ 不是 $R$ 的超码且 $\alpha \to \beta$ 不是平凡的:

- $(\alpha \cup \beta)$
- $(R-(\beta - \alpha))$

**分解算法**
$result := \{R\}$
    $done := false$;
    计算 $F^+$;
    **while** (**not** done) **do**
        **if**(result中存在模式$R_i$不属于BCNF)
        **then begin**
            令 $\alpha \to \beta$ 为一个在 $R_i$ 上成立的非平凡函数依赖, 满足 $\alpha \to R_i$ 不属于 $F^+$, 并且 $\alpha \cap \beta = \phi$;
            $result := (result- R_i)\cup(R_i-\beta)\cup(\alpha, \beta)$
    **end**
    **else** $done := true$;

算法中 $\alpha \to R_i$ 不属于 $F^+$ 说明 $\alpha$ 不是 $R_i$ 的超码, $\alpha \cap \beta = \phi$ 保证 $(R-(\beta - \alpha)) = R-\beta$, 在这两个限制条件下, 该算法也就和本小节最开始说的分解方式相同.

### 第三范式

#### 定义

对于 $F^+$ 中所有形如 $\alpha \to \beta$ 的函数依赖(其中 $\alpha \subseteq R$ 且 $\beta \subseteq R$), 以下至少一项成立:

- $\alpha \to \beta$ 是平凡的函数依赖
- $\alpha$ 是 $R$ 的一个超码
- $\beta - \alpha$ 中的每个属性 $A$ 都包含于 $R$ 的一个候选码中(可以是不同的候选码)

#### 3NF分解

**算法**

令 $F_c$ 为 $F$ 的正则覆盖;
$i:=0$;
**for each** $F_c$ 中的函数依赖 $\alpha \to \beta$
    $i := i+1$;
    $R_i := \alpha\beta$;
**if** 模式 $R_j, j=1, 2, \dots, i$ 都不包含 $R$ 的候选码
**then**
    $i:=i+1$;
    $R_i:=R$ 的任意候选码;
**repeat**
    **if** 模式 $R_j$ 包含于另一个模式 $R_k$ 中
    **then**
    $R_j := R_i$;
    $i:=i-1$;
**until** 不再有可以删除的 $R_j$
**return** $(R_1, R_2, \dots, R_i)$
